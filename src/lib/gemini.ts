
import { GoogleGenAI, Type } from "@google/genai";

// Types derived from source usage
export interface FrequencyInsight {
    day: number;
    archetype: string;
    summary: string;
    seeking: string;
    shadow: string;
    consultantNote?: string;
}

// Helper to get API Key safely
const getApiKey = () => {
    const key = process.env.GEMINI_API_KEY || process.env.NEXT_PUBLIC_GEMINI_API_KEY;
    if (!key) {
        console.warn("Missing GEMINI_API_KEY environment variable");
        return "";
    }
    return key;
};

export const transformToCat = async (imageBuffer: string): Promise<{ catImage: string, description: string, eyeColor: string }> => {
    const apiKey = getApiKey();
    if (!apiKey) throw new Error("API Key missing");

    const ai = new GoogleGenAI({ apiKey });
    const prompt = `
    TASK: Replace the human in this selfie with a cat avatar. 
    STRICT REQUIREMENTS:
    1. HEAD & HAIR REMOVAL: Completely remove the human head, neck, and ALL human hair. No human hair or skin should remain visible.
    2. FUR LENGTH: Match the cat's fur length to the human's hair length.
    3. CLOTHING: The cat's body must wear the exact same clothing colors and patterns as the human.
    4. BACKGROUND: The background must be 100% identical to the original photo.
    5. POSE: The cat must maintain the exact physical pose of the human.
    6. EYES: The cat's iris color must be the same as the human's iris color.
    
    OUTPUT: Provide the generated image and a text part naming the detected iris color (e.g., "Iris color: Amber").
  `;

    // Handle base64 string cleaning if necessary
    const cleanBuffer = imageBuffer.includes('base64,') ? imageBuffer.split('base64,')[1] : imageBuffer;

    const imagePart = {
        inlineData: {
            mimeType: 'image/png',
            data: cleanBuffer,
        },
    };

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.0-flash', // Updated to latest available flash or pro model for stability
            contents: { parts: [{ text: prompt }, imagePart] }, // Correct format for latest SDK
            config: {
                // imageConfig is not standard in all SDK versions, removing strictly constrained config if checking fails
                // but keeping the intent of the prompt.
            }
        });

        let catImage = '';
        let eyeColor = 'Prismatic';

        const parts = response.candidates?.[0]?.content?.parts || [];
        for (const part of parts) {
            if (part.inlineData) {
                catImage = `data:image/png;base64,${part.inlineData.data}`;
            } else if (part.text) {
                const eyeMatch = part.text.match(/iris color:?\s*([^.\n]+)/i) || part.text.match(/eye color:?\s*([^.\n]+)/i);
                if (eyeMatch) eyeColor = eyeMatch[1].trim();
            }
        }

        // Fallback if no image returned (some models might just return text)
        if (!catImage) {
            console.warn("No image generated by Gemini, checking response structure", response);
        }

        return { catImage, description: 'Feline Proxy Layered', eyeColor };
    } catch (error) {
        console.error("Gemini Transformation Error:", error);
        throw error;
    }
};

export const generateFrequencyInsight = async (day: number, answersSoFar: string[], coreTruth: string): Promise<FrequencyInsight> => {
    const apiKey = getApiKey();
    const ai = new GoogleGenAI({ apiKey });
    const prompt = `
    Dating Frequency Experiment Analysis Protocol.
    CORE TRUTH: "${coreTruth}"
    ANSWERS TO THE 5 PROTOCOL QUESTIONS:
    ${answersSoFar.join("\n")}
    
    Based on these semantic inputs, provide a psychological profile of what kind of partner they are subconsciously seeking.
    Return a response in JSON format.
  `;

    const response = await ai.models.generateContent({
        model: 'gemini-2.0-flash',
        contents: { parts: [{ text: prompt }] },
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    archetype: { type: Type.STRING, description: "A 2-3 word name for their current vibe (e.g. 'The Stoic Architect')" },
                    summary: { type: Type.STRING, description: "A 1-sentence summary of their current frequency" },
                    seeking: { type: Type.STRING, description: "Who they are REALLY searching for right now" },
                    shadow: { type: Type.STRING, description: "A trait they are likely suppressing but need in a partner" }
                },
                required: ["archetype", "summary", "seeking", "shadow"]
            }
        }
    });

    const text = response.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!text) throw new Error("No text response from Gemini");

    return {
        day,
        ...JSON.parse(text.trim())
    };
};

export const rankResonance = async (userAnswer: string, pool: { id: string, answer: string }[]): Promise<{ id: string, score: number }[]> => {
    const apiKey = getApiKey();
    const ai = new GoogleGenAI({ apiKey });
    const candidatesString = pool.map(p => `ID: ${p.id} | Answer: ${p.answer}`).join('\n');

    const prompt = `
    USER ANSWER: "${userAnswer}"
    CANDIDATES:
    ${candidatesString}
    Evaluate how much the USER ANSWER resonates with each CANDIDATE. Return resonance scores (0.0 to 1.0).
  `;

    const response = await ai.models.generateContent({
        model: 'gemini-2.0-flash',
        contents: { parts: [{ text: prompt }] },
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        id: { type: Type.STRING },
                        score: { type: Type.NUMBER }
                    },
                    required: ["id", "score"]
                }
            }
        }
    });

    try {
        const text = response.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!text) return pool.map(p => ({ id: p.id, score: 0.5 }));
        return JSON.parse(text.trim());
    } catch (e) {
        console.error("Error parsing resonance score:", e);
        return pool.map(p => ({ id: p.id, score: 0.5 }));
    }
};

export async function generateDatingInsight(userAnswers: string[], coreTruth: string): Promise<string> {
    const apiKey = getApiKey();
    const ai = new GoogleGenAI({ apiKey });

    const prompt = `
    Role: You are a brutally honest but mystical "Cat Dating Consultant". 
    Task: Analyze the user's answers to these psychological questions and their self-proclaimed "Core Truth".
    Goal: Identify ONE major contradiction or ONE major alignment in their dating frequency.
  
    User's Core Truth: "${coreTruth}"
    User's Choices:
    ${userAnswers.join('\n')}
  
    Output: A short, 2-sentence "Truth Bomb". 
    - Sentence 1: Call out the behavior.
    - Sentence 2: Give a cryptic directive.
    - Tone: Cosmic, slightly judgmental, feline, but ultimately helpful.
    - Do NOT describe the questions. Describe the SOUL.
  
    Example: "You claim to want 'Peace', but you keep choosing 'Chaos' and 'Fire'. Stop hunting mice if you actually want to nap."
    `;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.0-flash',
            contents: { parts: [{ text: prompt }] }
        });
        return response.candidates?.[0]?.content?.parts?.[0]?.text || "Your frequency is currently clouded. Meditate on your choices.";
    } catch (error) {
        console.error("Insight Gen Error", error);
        return "The spirits are silent. Your signal is too complex.";
    }
}

